<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
k2{
	font-family: "Arial";
    color: #990000;
	font-weight: bold;
	font-size: 95%;
}
pre{
	font-family: "Consolas";
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	 
    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #ccffcc;
    font-size: 100%;
	width: 95%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;

}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
</style>
    
<head>
   
<title>Landolfi_Luca_iss0_a (BoundaryWalk)</title></head>
    
<body>
<div id="top">
<h1>(BoundaryWalk) Landolfi_Luca_iss0_a<font size="5"></font> </h1>
</div>  

<div class="body"> 
<h2>Introduction </h2>
 
Motto:
<k>there is no code without a project, no project without problem analysis and no problem without requirements</k>



<h2>Requirements</h2>
 
<div class="remark">
Design and build a software system that leads a robot to walk along the boundary of a empty, rectangular room.
</div>
 

<h2>Requirement analysis</h2>
 
The <b>interaction with the client</b> made it clear that he associates the following meaning with nouns:
<ul>
<li><k2>room</k2>: a conventional room, as found in all buildings, with no obstacle ("empty")</li>
<li><k2>boundary</k2>: perimeter of the room, physically bounded by solid walls</li>
<li><k2>robot</k2>: a device capable of moving by receiving commands via the network, as reported in
<a href="VirtualRobot2021.html#commands" target="web"><ks>VirtualRobot2021.html</ks></a>.
 </li>
</ul>

For the verbs:
<ul>
<li><k2>walk</k2>: the robot must move forward, hugging the walls of the room.</li>
</ul>

<h3>A starting <a href="https://en.wikipedia.org/wiki/User_story" target="web">user story</a></h3>

 <table style="width:98%">
<tbody>	
<tr>
<td style="width:60%" >
 
As a client, I place the robot in the HOME cell (facing south) and then I activate a system
which sends movement commands to the robot (via wifi network). 
<br/>
As a user I cannot interrupt the execution: the system must terminate autonomously, once the task has been performed.
<br/><br/>
When the system is finished running,
I expect that the robot has completed (only one time) the path shown in the figure.
 
</td>
<td><center><img src="./img/robot-in-room.png" alt="TestPlan0" width="60%" ></center>
</td>
</tr>
 </tbody>
</table>





<h4>Test Plan: Verification of expected results</h4> 

It is necessary to verify that the path taken by the robot is the one expected.

<div class="remark" style="margin-left:-5px; margin-right:5px; padding-left:5px;">
The verification of the congruence of the path must be carried out via software, without the intervention
of a human user.
</div>
We will do it by inferring knowledge by robot response.
Test Plan will be like this:
<ul>
	<li><k2>Functional TestPlans</k2>: Verify that the sequence of results replied by the robot is correct. 
		We must set a movement time that allows the robot to move his lenght (forward or back) and repeat the forward command as many times as he don't hit the wall,
		then we have to check that the robot executes this cycle 4 times, and check his command move, and that the space he did is the same of the perimeter.
		We can try to represent the room and track the robot path.
		<ul> 
			<li>The first movement command goes to "endmove: true";</li> 
			<li>The movement command "endmove: false" detecting a collision;</li>
			<li>Turn left;</li>
			<li>Check that the robot always turns in the same direction.</li>
			<li>Check the distance done by the robot is the same of the boundary</li>
		</ul>
	</li>
</ul>


<h2>Problem analysis</h2>

<h3>Relevant aspects</h3>

<ol>
<li>
Create a <ks>Distributed System</ks> consisting of two macro-components:
	<ul>
	<li>The <ks>Robot</ks> provided by the customer </li>
	<li>The <ks>Application</ks> (<ks>BoundaryWalk</ks>) which sends commands to the robot in order to meet the requirements</li>
	</ul>
</li>
<li> The robot can be controlled via the network in two different ways, as described in
<a href="VirtualRobot2021.html#commands" target="web">VirtualRobot2021.html: commands</a>:
	<ul>
	<li>sending messages to the port <tt>8090</tt> with HTTP POST protocol </li>
	<li>sending messages to the port <tt>8091</tt> with a websocket</li>
	</ul>
</li>
<li>
Since there are numerous libraries in many programming languages ​​that allow the sending of such commands,
no significant <ks>abstraction-gap</ks> is identified on an operational level.
<div class="remark">
However there is a <k>abstraction gap on a conceptual level</k>: there are two possible technologies for communicating
with the robot and each requires appropriate supports. However conceptually it is always about setting a
 <ks>request-response interaction scheme</ks>.
</div>
</li>

<li>
We estimate that a first prototype of the application should take one day and half to be realized).
</li>
</ol>


<h3>Architettura logica</h3>

<table style="width:98%">
<tr>
<td style="width:40%" >
<center><img src="./img/iss0_logicArch0.png" alt="iss0_logicArch0" width="70%" ></center>
</td>
<td> Legenda:
 <center><img src="./img/legenda.png" alt="legenda" width="50%" ></center>
</td>
</tr>
</table>
The exact nature of the component <ks>BoundaryWalk</ks> will be defined in the design phase.
<br/><br/>
For the interaction:
<ul>
<li>the use of the HTTP protocol seems completely adequate;</li>
<li>use of the websocket may prove to be <i>more flexible</i> (as it allows you to also receive
<k> information issued by WEnv in a 'spontaneous' way</k>) and <i>more efficient</i> (reduce the protocol hierarchy).</li></li>
</ul>



 
 
<h3>Problems identified</h3>

<ol>

<li><h4>Interaction Abstraction</h4>
The software system should be made as independent as possible from the communication protocol used for the interaction with WEnv.
<br/><br/>
The designer could use some <a href="https://it.wikipedia.org/wiki/Design_pattern" target="web"><ks>design pattern</ks></a> 
to make the application layer as <k> invariant </k> as possible with respect
to the communication protocol, which could be selected in a <k> configuration phase </k> of the system.
We can use a command Pattern? <kc>###</kc>
</li>

<li><h4>Testing</h4>
The goal of defining an automatable <tt> TestPlan </tt> actually introduces a <k> new requirement </k>:
make the application observable, or better make its effects verifiable, by a machine. 
<br/>
It is not enough to induce the robot to move;
in the absence of cameras and / or special environmental sensors, one way to proceed is to <ks> <i> infer knowledge </i> </ks> by
the commands sent and the responses obtained from WENV and <ks> explicitly represent </ks> that knowledge.
<br/><br/>
A possible strategy is to create within the application, a sort of <k> <i> 'mind map' </i> </k> capable of providing a model of the robot's actions,
on which a testing program can 'reason' to carry out the verifications.
<br/><br/>
More specifically, given the information on how to use the robot, we can prefigure that the solution to the problem consists of the following algorithm:
<pre>
the robot starts from the HOME position, facing south (DOWN)
for 4 times:
send <kc> moveForward </kc> commands to the robot until the robot hits the opposite wall
and then I issue a <kc> turnLeft </kc> rotation command
</pre>
</li>

</ol>

<h4>Possible strategies for TestPlan: 'infer knowledge' from commands</h4>

Based on this analysis, we can outline a testing strategy. 
To make the discussion easier, we introduce the following abbreviations
related to commands <a href="VirtualRobot2021.html #cril" target="web">cril</a>:
<pre>
<ks>w</ks> : for the move <kc>{"robotmove":"moveForward", "time": 600}</kc>
<ks>s</ks> : for the move <kc>{"robotmove":"moveForward", "time ":600}</kc>
<ks>h</ks> : for the move <kc>{"robotmove":"moveForward", "time ":100}</kc>
<ks>l</ks> : for the move <kc>{"robotmove":"turnLeft ",   "time ":300}</kc>
<ks>r</ks> : for the move <kc>{"robotmove":"turnRight",   "time ":300}</kc>
</pre>
<br/>
<h4>TESTPLAN (Modification of Test-Plan 3):</h4> 
First set the <kc> time </kc> for the moves <ks> w, s </ks> in order to obtain movements of <k> robot-units </k>
(the robot do a space pair to his lenght). We build a incremental <k> territory map </k> after each move populating a matrix in wich the robot starts from the HomeCell(supposed Left-Upper angle of teh room) position facing south. 
This way you could know where the robot is after each command and then you could check the path taken and the distance traveled by the robot at the end of the application; 
for example (<kc> 1 </kc> represents the 'cells' traveled by the robot):
<pre>
|1, 1, 1, 1, 1, 
|1, 0, 0, 0, 1, 
|1, 0, 0, 0, 1, 
|1, 0, 0, 0, 1, 
|1, 1, 1, 1, 1, 
</pre>
At the end the Submatrix B[1:n-1, 1:n,1] have to be populated by all zero, and counting the ones and multiplicating for the robot lenght we have to get the perimeter of the room.
</li>
<br/>

<h4>Implemented TestPlan code:</h4>
<pre style="font-family: 'Courier New', monospace; font-size:10pt;">
public class TestPlan3PersonalizedBoundaryWalk {
    private MoveVirtualRobot appl;

    @Before
    public void systemSetUp() {
        System.out.println("TestMoveVirtualRobot | setUp: robot should be at HOME-DOWN ");
        appl = new MoveVirtualRobot();
    }

    @After
    public void  terminate() {
        System.out.println("%%%  TestPlan1 |  terminates ");
    }

    @Test
    public void testPlan3BoundaryWalk(){
        //Dati del committente in metri
        double lR = 2.4, lC = 2.4;
        double perimetro = (lR*2)+(lC*2);
        double RobotLen = 0.6;
        double RobotSpeed = 0.2;
        int time = (int) (100 * RobotLen/RobotSpeed);
        int homePosR = 1, homePosC = 1; //Cella di partenza


        //Start Test
        int room[][];

        room = boundaryWalk(time, appl, homePosR, homePosC);

        for(int i =0;i<=lR/RobotLen+1+homePosR;i++){
            for(int j=0; j<=lC/RobotLen+1+homePosC; j++){
                System.out.print(room[i][j]);
            }
            System.out.print("\n");
        }


        int i=homePosR, j=homePosC, count=0;
        while (room[i][j] == 1){
            i++;
            count++;
        }
        if(room[--i][++j]==0)
            fail();
        while(room[i][j]==1) {
            j++;
            count++;
        }
        if(room[--i][--j]==0)
            fail();
        while (room[i][j] == 1 && i>0) {
            i--;
            count++;
        }
        if (++i==homePosR) {
            if (room[i][--j] == 0)
                fail("Errore in angolo nord-est");
        }else
            fail("Robot oltre la riga di partenza!");

        while (room[i][j] == 1 && j>0) {
            j--;
            count++;
        }
        if (++j!=homePosC)
            fail("Errore Robot non tornato nel punto di partenza: Room["+i+","+j+"]");
        else
            count--;

        System.out.print("D: "+ count*RobotLen +"m\tL: "+ perimetro+"m\n");
        if((count*RobotLen) != perimetro)
            fail("d!=p -> La distanza percorsa dal robot non corrisponde alla lunghezza perimetro!");
    }

    private static final int SUD = 0;
    private static final int EST = 1;
    private static final int NORD = 2;
    private static final int OVEST = 3;

    public int[][] boundaryWalk(int time, MoveVirtualRobot robot, int homeR, int homeC){
        int room[][] = new int[200][200];

        room[homeR][homeC] = 2;
        int direction = 0;
        int r=homeR,c=homeC;
        boolean moveFailed;

        for(int i=0; i<4; i++) {
            do {
                moveFailed = robot.moveForward(time);
                if(!moveFailed) {
                    switch (direction) {
                        case SUD:
                            r++;
                            break;
                        case NORD:
                            r--;
                            break;
                        case EST:
                            c++;
                            break;
                        case OVEST:
                            c--;
                    }
                    room[r][c] = 1;
                }
            }while(!moveFailed);
            moveFailed = robot.moveLeft(200);
            if(!moveFailed){
                direction++;
            }else
                assertTrue(!moveFailed);
        }

        return room;
    }
}
</pre>
 

 
 
</div>

	      	
<br/><br/> 	
</div>  
<hr/>
<div style="background-color:rgba(86, 56, 253, 0.9); width:30%;text-align:left;color:white; padding-bottom:10px; padding-top:5px; padding-right:5px; padding-left:5px;">

<h3>
	By LUCA LANDOLFI email: luca.landolfi3@studio.unibo.it<br/>
	GitHub : <a href="https://github.com/LucaLand/LandolfiLuca">https://github.com/LucaLand/LandolfiLuca</a>
</h3> 
<img src="./img/Luca_Teams01.jpg" alt="LandolfiLuca" width="150px" height="150px">

</div>

</body>
</html>